<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Btista">
<meta property="og:url" content="https://btista.github.io/index.html">
<meta property="og:site_name" content="Btista">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Btista">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://btista.github.io/"/>


  <title> Btista </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Btista</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/let-和-const-命令/" itemprop="url">
                  let 和 const 命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-01T17:56:04+08:00" content="2017-03-01">
              2017-03-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.let命令，只在命令所在的代码块内有效/可访问。（代码块也就是花括号{}）</p>
<p>for循环的计数器，就很合适使用let命令。<br>参考下面两块代码，体会“ let声明的变量仅在块级作用域内有效 /可访问 ”<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p>2.使用let,不存在变量提升现象。</p>
<p> 这意味着只要let声明语句还没有执行，调用这个变量就会报错，而不是得到undefined。</p>
<p> 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p>
<p> ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.使用let，不允许（在同一个代码块中）重复声明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>ES6的块级作用域<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码如果是用var声明的话，console的结果应该是10</p>
<p>ES6 允许块级作用域的任意嵌套。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure></p>
<pre><code>外层作用域无法读取内层作用域的变量，和函数外无法读取函数内的变量一样。

同理，块级作用内部的块级作用域可以读取外层的变量，仍然遵守“先在本级找，没有的话去父级找，直至顶层”。

当然， 内层作用域也可以定义外层作用域的同名变量，因为根本就不是一个作用域。

同样的，在块级作用域中声明的函数就像let一样，在块级外无法访问。就好比我们在函数内部声明的函数一样。

实际上，一个块级作用域{}，里面写一些代码，其作用和立即执行函数（ IIFE ）是一样的。
</code></pre><p>5.const<br>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const的作用域与let命令相同：只在声明所在的块级作用域内有效 。const命令声明的常量也是不提升，同样存在暂时性死区 。</p>
<p>本质<br>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></div><div class="line">foo.prop = <span class="number">123</span>;</div><div class="line">foo.prop <span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></div><div class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></div></pre></td></tr></table></figure>
<p>6.ES6声明变量有六种方法<br>以前只用var 和 function 两种声明变量的命令。<br>现在有六种，分别是 var , function , let , const, class, import</p>
<p>7.顶层对象</p>
<p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。<br>而在ES6中， var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></div><div class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>8.在ES6中，什么情况下使用var, 什么情况下使用let ？</p>
<p>For ES6: Adopt let and const. Stop using var.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/22/simpleCodeSkill/" itemprop="url">
                  simpleCodeSkill
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-22T15:03:05+08:00" content="2017-01-22">
              2017-01-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.输出一个字符串的所有可能的片段（并不是所有随机组合，是所以可能的片段）<br>for (var i=0;i&lt;str.length;i++){<br>        for (var j=i+1; j&lt;str.length+1;j++){<br>          console.log(str.slice(i,j))<br>        }</p>
<p>}<br>2.for (whatever in obj){<br>    console.log(whatever)<br>}<br>whatever 指的永远是obj的属性，你可以用prop, key ,keys或者任何东西来替代。<br>想访问指只能<br>for (whatever in obj){<br>    console.log(obj[whatever])<br>}</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/05/15.5/" itemprop="url">
                  Javascript中多种模块化的用法及其对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-05T10:14:21+08:00" content="2016-12-05">
              2016-12-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在这篇文章中主要写的是各个模块化的基础写法和其对比，旨在辨认哪种写法是哪种模块化。</p>
<h1 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h1><p>CommonJS规范多应用于后端，在nodejs中应用的比较多，遵循CommonJS规范的模块化写法写出来是这样的：<br>在CommonJS中每个js文件就是一个独立的模块，只有把其暴露给module.exports时它才在可以用require获取到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a.js</span></div><div class="line"><span class="keyword">var</span> a=&#123;</div><div class="line">	<span class="attr">mothodA</span>: <span class="string">'a'</span>,</div><div class="line">	<span class="attr">mothodB</span>: <span class="string">'b'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports=a;</div><div class="line"><span class="comment">//b.js</span></div><div class="line"><span class="keyword">var</span> a=<span class="built_in">require</span>(./a.js)</div><div class="line"><span class="keyword">var</span> $=<span class="built_in">require</span>(<span class="string">'jquery'</span>)</div><div class="line"><span class="comment">//那么在b.js后面就可以使用jquery和a对象了</span></div></pre></td></tr></table></figure></p>
<p>CommonJs写法多用于服务器端，而很少应用于浏览器端，因为CommonJS的写法是同步的。<br>也就是说比如在上方的b.js中，我们一定得等a.js require过来了，才可以继续读下面的代码，线程会被阻塞住，所以它不适合直接应用于浏览器端。</p>
<h1 id="2-AMD（Asynchromous-Module-Definition）异步模块规范。"><a href="#2-AMD（Asynchromous-Module-Definition）异步模块规范。" class="headerlink" title="2.AMD（Asynchromous Module Definition）异步模块规范。"></a>2.AMD（Asynchromous Module Definition）异步模块规范。</h1><p>1.AMD加载模块是异步的。<br>2.define([‘dep1’,’dep2’],function(dep1,dep2){…});<br>AMD只有一个接口即：define(id?,dependencies？，factory);  （问号代表非必须）<br>3.reqireJS依照的就是AMD规范，即require的写法就是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> &#123;</div><div class="line">           <span class="attr">mix</span>: <span class="function"><span class="keyword">function</span>(<span class="params">source, target</span>) </span>&#123;</div><div class="line">               ...</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//b.js 依赖a.js</span></div><div class="line">    define([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<h1 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h1><p>CMD和AMD的区别主要是CMD提倡“依赖就近”，AMD提倡“依赖前置”<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AMD写法</span></div><div class="line">    define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="comment">//依赖一开始就写好</span></div><div class="line">        a.mix();</div><div class="line">        b.show();</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//CMD写法</span></div><div class="line">    define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</div><div class="line">        <span class="comment">//依赖可以就近书写</span></div><div class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line">        a.mix();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (...) &#123;</div><div class="line">            <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>);</div><div class="line">            b.show();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<h1 id="4-ES6-Module"><a href="#4-ES6-Module" class="headerlink" title="4.ES6 Module"></a>4.ES6 Module</h1><p>ES6的模块有很多细节和特性，这里只简单的指出其写法，以区分于其他模块写法。<br>export<br>和AMD一样，ES6的模块是一个包含js的代码文件，在模块中声明的所有变量和函数都是私有的，如果想对其他模块public，就需要export这部分代码。<br>直接在变量、函数或者别的声明前面加export就可以使其暴露出来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Kittydar</span> </span>&#123;</div><div class="line">  ... several methods doing image processing ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在其他文件中可以导入这个模块并且使用kittydar这个类<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Kittydar&#125; <span class="keyword">from</span> <span class="string">"kittydar.js"</span>;</div></pre></td></tr></table></figure></p>
<p>贴一个demo：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">someFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">do</span> something;</div><div class="line">	);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h1><p>在后续的文章中我再详细写两个话题 1.require.js的一些具体用法细节 2. ES6 Module 的特性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/02/11.2/" itemprop="url">
                  A simple example about javascript module.
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-02T16:48:44+08:00" content="2016-11-02">
              2016-11-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><figcaption><span>moduleVariable= moduleVariable || &#123;&#125;;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">moduleVariable.planA=(function()&#123;</div><div class="line">	// define some variable privately , it can only be used within this function.</div><div class="line">	var someVariable=&#123;</div><div class="line">		a : &apos;a&apos;,</div><div class="line">		b : &apos;b&apos;,</div><div class="line">		c : &apos;c&apos;</div><div class="line">	&#125;;</div><div class="line">	//define a couple of object to include some functions. one for privately , the other one for public.</div><div class="line">	var private = &#123;&#125;;</div><div class="line">	var public = &#123;&#125;;</div><div class="line">	/*this is private method below , due to the object private can only be visited in this function , so the method belong to </div><div class="line">	this object can only be visited in this function*/</div><div class="line">	private.functionA=function()&#123;</div><div class="line">		/*Do something*/</div><div class="line">		console.log(someVariable.a);// it can visite someVariable;</div><div class="line">	&#125;</div><div class="line">	private.functionB=function()&#123;</div><div class="line">		/*Do something else*/</div><div class="line">		console.log(private.functionA);// it can visite private.functionA;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public.init=function()&#123;</div><div class="line">		var a=someVariable.a;</div><div class="line">		private.functionA();</div><div class="line">		private.functionB();//it can visite variables and functions in this function.	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return public; //在最后我们返回了public，那么在外部moduleVariable.planA就等于public,moduleVariable.planA可以访问到public的init方法</div><div class="line">				   //但是其他所有的变量，私有方法（private），都没有暴露给外部，只在public的init()方法中可以被使用</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">$(document).ready(function()&#123;</div><div class="line">	moduleVariable.planA.init();//Be invoked here.</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/函数传参引发的一些小问题/" itemprop="url">
                  函数传参引发的一些小问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T14:04:21+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 一个很简单的问题，自己在试验中还引发了不少别的问题<br>  即当我们把一个全局变量当做变量传给一个函数，并且在这个函数内部处理这个变量的时候，最外层的全局变量的值并不会改变，因为我们处理的是传<br>进来的参数而非全局变量，就像以下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> globalA=<span class="string">'10'</span>;</div><div class="line">    <span class="keyword">var</span> func=&#123;&#125;;</div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">globalA</span>)</span>&#123;</div><div class="line">         globalA++;</div><div class="line">         <span class="built_in">console</span>.log(globalA);</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(globalA);</div><div class="line">             <span class="built_in">window</span>.func.B=B;</div><div class="line">&#125;</div><div class="line">    &#125;)(globalA)</div></pre></td></tr></table></figure></p>
<p>  A函数console出来的globalA和func.B运行console出来的globalA都变了，但是全局函数globalA仍然是10；<br>  因为你在函数内部调用的并不是全局函数globalA，而是函数自己创建的arguments对象<br>引发的第一个问题是 ：我本以为直接把globalA当做参数，就能将外层的值引进来，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalA=<span class="string">'10'</span>;</div><div class="line"><span class="keyword">var</span> func=&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">globalA</span>)</span>&#123;</div><div class="line">	globalA++;</div><div class="line">	<span class="built_in">console</span>.log(globalA);</div><div class="line">	</div><div class="line">	 <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		       <span class="built_in">console</span>.log(globalA);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">window</span>.func.B=B;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  结果当然是可笑的，参数globalA和全局函数globalA一点关系都没有，这也印证了我们最初学js时书上讲函数创建时，函数的参数会被声明为一个<br>arguments对象，类似于数组。那么我们的参数就只是声明的一个对象而已，跟外界的变量并无关系，而将全局函数传给这个函数，只是给arguments[0]<br>赋值，即我们在处理arguments[0]，当然不会影响全局边框globalA。</p>
<p>  引发的第二个问题是当在函数内部返回function B而不是声明它时，window.func.B=B这一暴露B给全局变量的做法就失效了，因为执行这行代码<br>时B还没声明呢。即：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalA=<span class="string">'10'</span>;</div><div class="line"><span class="keyword">var</span> func=&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">globalA</span>)</span>&#123;</div><div class="line">	globalA++;</div><div class="line">	<span class="built_in">console</span>.log(globalA);</div><div class="line">	</div><div class="line">	 <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		       <span class="built_in">console</span>.log(globalA);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">window</span>.func.B=B; <span class="comment">//B还未声明，暴露失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  这本身没声明，但是我又想到了这个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">    funcs[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"My value: "</span> + index);</div><div class="line">        &#125;;</div><div class="line">    &#125;(i));</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</div><div class="line">    funcs[j]();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  这个闭包结构，按我们上面的说法，在for循环做完时return后面跟的那3个匿名函数都是没有声明的，只是作为返回值赋给了funcs数组的三个坑，<br>则他们真正声明的时候是funcs<a href="">j</a>;一声明就执行<br>  于是我在想，他们声明的位置变了，却仍然能用闭包的特性保留住哪个特殊作用域的i值，这不是跟闭包的词法作用域相悖吗<br>  但是后来又想想，既然函数被调用时，内部能调到的的作用域只和他们的词法作用域有关，那么词法作用域应该是指更严格的“函数写在哪儿”，哪怕<br>他们虽然写在那儿但是他们并没有在那儿声明呢<br>  不过也可能是我理解错了，所以先记在这里吧</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/An-overview-of-the-OPP/" itemprop="url">
                  An overview of the OPP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T14:00:34+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.JavaScript语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）</p>
<p>2.new命令的作用，就是[执行]构造函数，返回一个实例对象.new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。<br>3.new命令的内部原理：执行new命令后，先创建一个空的上下文对象，然后赋值给构造函数中的this，在new命令执行完毕后，如果构造函数中return了<br>一个对象，new命令就会返回return语句指定的对象（如果return了一个无关的对象，那new命令也会返回这个对象），如果return语句返回的不是对象或者<br>没有return语句，那么new命令就会返回this对象（即构造后的上下文对象）。</p>
<p>4.instanceof<br>4.1 instanceof运算符返回一个布尔值，用于判断运算符左边的实例对象是否由运算符右边的构造函数所创建<br>4.2 在javascript中，所有的对象都有对应的构造函数（constructor），所以instanceof运算符可以用来判断值的类型<br> [1,2,3] instanceof Array  //true<br>4.3  instanceof只能用于对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">'hahaha'</span>;</div><div class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false  cause this is a string type,not object</span></div><div class="line"><span class="keyword">var</span> str=<span class="keyword">new</span> <span class="built_in">String</span>();</div><div class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//true   cause 'new String' generate a object type</span></div></pre></td></tr></table></figure></p>
<p>5.this<br>  this指向函数运行时，函数所处的对象（调用该函数的对象）<br>  直接在全局环境调用的话，this指的就是window对象<br>  如果是a.b()这样的调用，那b方法中的this自然就是指a对象<br>  $(selector).click(function(){console.log(this)})  这样的调用，this指的就是selector被$化后的jQuery对象<br>  在Node.js中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。<br>6.call apply方法<br>  “函数的call方法，可以指定该函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。”<br>  在我的理解中，一共有两点：第一是【call别的对象的方法】（如下面的Object.prototype.hasOwnProperty）内部的this都会指向obj<br> 第二是把【call别的对象的方法】（如下面的Object.prototype.hasOwnProperty）视作一个整体，让obj去调用这个方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="string">'toString'</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/13/事件冒泡机制和事件委派-以及回调的匿名函数参数/" itemprop="url">
                  事件冒泡机制和事件委派 以及回调的匿名函数参数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-13T18:40:47+08:00" content="2016-04-13">
              2016-04-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.事件冒泡机制：</p>
<p>事件冒泡机制也就是当一个事件绑定到一个元素上时，如果这个元素不存在或者回调函数返回ture,那么这个事件就会向上冒泡，继续绑定这个元素的父级元素直至document。（如果事件返回return false则不会冒泡）</p>
<p>阻止冒泡：1.事件return false ; 2.evt.stopPropagation(这个evt指此次事件，写在事件匿名回调函数的参数里)例如： $(‘li’).click(function(evt){evt.stopPropagation()});</p>
<p>2.事件委托：</p>
<p>jQuery的on方法和delegate方法都可以给未来出现的元素绑定事件，原理就是利用事件冒泡机制</p>
<p>on方法和delegate方法会将【事件处理函数】绑定（委托）在需要绑定的元素的父级元素上，当其子元素触发事件时，这个事件会冒泡上来触发父元素身上的【事件处理函数】，而这个过程中会判断这个事件发生的元素是否是子元素，如果不是子元素，就不执行【事件处理函数】；</p>
<p>具体思路是下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取父节点，并为它添加一个click事件</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"parent-list"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="comment">// 检查事件源e.targe是否为Li</span></div><div class="line">  <span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName.toUpperCase == <span class="string">"LI"</span>) &#123;</div><div class="line">    <span class="comment">// 真正的处理过程在这里</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"List item "</span>,e.target.id.replace(<span class="string">"post-"</span>),<span class="string">" was clicked!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>e是这个事件，e.target事件发生的元素/事件源；</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/11/You-Don-t-Know-JS-Scope-Closures-翻译/" itemprop="url">
                  You Don't Know JS: Scope & Closures(翻译)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-11T11:14:16+08:00" content="2016-04-11">
              2016-04-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Chapter 1: What is Scope?<br>第一章：什么是作用域</p>
<p>One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the ability to store values and pull values out of variables is what gives a program state.</p>
<p>在几乎所有编程语言中，储存值到变量中和稍后检索或改变这些值都是最基本的能力之一。事实上，这种存储值到变量和将值移除变量的能力才给了程序以“状态”。</p>
<p>Without such a concept, a program could perform some tasks, but they would be extremely limited and not terribly interesting.</p>
<p>没了这个概念的话，一个程序也能完成一些任务，但他们就会有很多地方被限制并且一点都不有趣了。</p>
<p>But the inclusion of variables into our program begets the most interesting questions we will now address: where do those variables live? In other words, where are they stored? And, most importantly, how does our program find them when it needs them?</p>
<p>但是把变量包含到我们的程序中带来的最有趣的问题是：这些变量在哪儿？或者说，他们存储在哪儿？最重要的是，当我们的程序需要这些变量的时候，它是如何找到他们的？</p>
<p>These questions speak to the need for a well-defined set of rules for storing variables in some location, and for finding those variables at a later time. We’ll call that set of rules: Scope.</p>
<p>这个问题需要一个定义明确的规则，用于存储变量在某些位置，以及在之后再找出这些变量，我们可以把这个规则叫：作用域</p>
<p>But, where and how do these Scope rules get set?</p>
<p>但是，作用域规则在哪儿设置？怎么设置的?</p>
<p>Compiler Theory<br>编译原理</p>
<p>It may be self-evident, or it may be surprising, depending on your level of interaction with various languages, but despite the fact that JavaScript falls under the general category of “dynamic” or “interpreted” languages, it is in fact a compiled language. It is not compiled well in advance, as are many traditionally-compiled languages, nor are the results of compilation portable among various distributed systems.</p>
<p>这可能是不言而喻的，或者可能令人惊讶——取决于你融会贯通各种语言的能力，但是尽管JS属于一般范畴的动态型和解释型语言，实际上它却是一个编译型语言。它不是提前编译好的，因为有许多传统编译语言也不是各种分布式编译系统的产物。</p>
<p>But, nevertheless, the JavaScript engine performs many of the same steps, albeit in more sophisticated ways than we may commonly be aware, of any traditional language-compiler.</p>
<p>但是，尽管如此，JS引擎也执行着许多相同的步骤，尽管它使用的是一种更为复杂的方式——比我们可能意识到的任何传统编译语言</p>
<p>In traditional compiled-language process, a chunk of source code, your program, will undergo typically three steps before it is executed, roughly called “compilation”: </p>
<p>在传统的编译语言过程中，一块源代码，也就是你的程序，会在执行前遵从典型的‘三步走’，也就是‘编译’</p>
<p>Tokenizing/Lexing: breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: var a = 2;. This program would likely be broken up into the following tokens: var, a, =, 2, and ;. Whitespace may or may not be persisted as a token, depending on whether it’s meaningful or not.</p>
<p>Note: The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a stateless or stateful way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether a should be considered a distinct token or just part of another token, that would be lexing.</p>
<p>1.分词/词法分析：分词指将一段字符串破成有意义的（相对于这门语言）小块。比如，考虑这段代码：var a=2;这条程序可能会被破成下面的部分：var , a, =,2,还有；  空白可能成为分词小块也可能不会，这得取决于它是否有含义。</p>
<p>注：分词和词法分析之间的区别既微妙又学术，但关键在于这些小块被明确为有状态的还是无状态的。简单点儿说，如果分词块儿调用的是有状态的词法分析规则，来区分a应该作为一个单独的词法块儿还是仅仅是另外一块词法块儿的一部分，那么这个过程就称作词法分析。（我的理解就是 把字符串分为有意义的tokens这是分词，确定每一小块代码段是应该独立还是应该和另外一块合并成一个token，这是词法分析）。</p>
<p>2.Parsing: taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This tree is called an “AST” (Abstract Syntax Tree).</p>
<p> The tree for var a = 2; might start with a top-level node called VariableDeclaration, with a child node called Identifier (whose value is a), and another child called AssignmentExpression which itself has a child called NumericLiteral (whose value is 2).</p>
<p>2.解析：取一段分词过的代码流，然后把它变成一个代表了程序语法结构的嵌套元素树，这个树的名字叫AST(Abstract Syntax Tree).</p>
<p> 在这个树状结构的解析中，对于var a=2;可能从最高层——变量声明（VariableDeclaration）开始，然后是它的子节点——标识符（Identifier）（它的值是a）,已经另外一个子节点AssignmentExpression的子节点叫NumericLiteral（它的值是2）。</p>
<p>3.Code-Generation: the process of taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it’s targeting, etc.</p>
<p> So, rather than get mired in details, we’ll just handwave and say that there’s a way to take our above described AST for var a = 2; and turn it into a set of machine instructions to actually create a variable called a (including reserving memory, etc.), and then store a value into a.</p>
<p> Note: The details of how the engine manages system resources are deeper than we will dig, so we’ll just take it for granted that the engine is able to create and store variables as needed.</p>
<p>3.代码生成：这个过程是使用AST将代码块变为可执行的代码，这部分的过程很依赖于语言本身，包括它的目标平台等。</p>
<p> 所以为了避免在细节里太纠结，我们就直接说上述的AST处理了我们的var a = 2；并且把它变成了一行机器指令——这行指令创造出一个变量a，并且存了一个值进去。</p>
<p> 注：引擎如何管理系统资源这是一个很深的坑，超出了我们的讨论范围。所以我们只需要知道引擎可以按需求创造出变量并且给它赋值就可以了。</p>
<p>  The JavaScript engine is vastly more complex than just those three steps, as are most other language compilers. For instance, in the process of parsing and code-generation, there are certainly steps to optimize the performance of the execution, including collapsing redundant elements, etc.</p>
<p>  JS引擎做的工作远比这三步要复杂，比如，在解析和代码生成这两步的过程中，还有一定的步骤去以优化性能的执行，包括折叠冗余元素等。</p>
<p>  So, I’m painting only with broad strokes here. But I think you’ll see shortly why these details we do cover, even at a high level, are relevant.</p>
<p>  所以，我们就言止于此好了，但是你很快就会意识到为什么我们需要关心这个，即使处于一个很高的水平，这些也是息息相关的。</p>
<p>   For one thing, JavaScript engines don’t get the luxury (like other language compilers) of having plenty of time to optimize, because JavaScript compilation doesn’t happen in a build step ahead of time, as with other languages.</p>
<p>   还有一件事是js引擎并不像其他语言编译一样有充分的时间去优化，因为js编译并没有像其他语言一样发生在构造之前</p>
<p>   For JavaScript, the compilation that occurs happens, in many cases, mere microseconds (or less!) before the code is executed. To ensure the fastest performance, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile, etc.) which are well beyond the “scope” of our discussion here.</p>
<p>  对于js来说，在许多情况下编译发生在执行这段代码前几微秒（或者更少！）的时间里，为了确保最快的性能，js引擎使用了各种技巧，这些都远远超出了我们讨论的“作用域”。</p>
<p>   Let’s just say, for simplicity’s sake, that any snippet of JavaScript has to be compiled before (usually right before!) it’s executed. So, the JS compiler will take the program var a = 2; and compile it first, and then be ready to execute it, usually right away.</p>
<p>  我们就这么说吧，为了简单起见，任何js代码都会在执行前被编译，所以，js编译器会拿走程序var a = 2，然后先编译它，然后准备去执行它。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/19/call-和原型继承的方法/" itemprop="url">
                  call()和原型继承的方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-19T17:53:52+08:00" content="2016-01-19">
              2016-01-19
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.call()</p>
<p>call()方法接受两个参数，obj和arg </p>
<p>比如functionA.call（obj,arg）   就是说现在运行(执行)functionA这个方法，但是functionA里面的方法不是为它以前的对象而运行了，把functionA的this强行改变成了obj</p>
<p>obj成为functionA中的this，然后来运行functionA这个方法，而arg是传给functionA的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    Student.call(<span class="keyword">this</span>, props);</div><div class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如上面的代码，先定义了Student方法，然后定义了PrimaryStudent方法<br>在PrimaryStudent中， Student.call(this, props);指的是把this——也就是PrimaryStudent对象作为Student运行时的那个this，把props传给Student作为参数，来运行Student这个方法，运行出来的结果是什么呢<br>PrimaryStudent.name=props.name //这个props是传进来那个props<br>然后PrimaryStudent.prototype.hello = function () { alert(‘Hello, ‘ + this.name + ‘!’); }   它还获得了一个写在原型里的方法<br>则PrimaryStudent这个函数运行下来的结果相当于<br>function PrimaryStudent(props){<br>this.name = props.name || ‘Unnamed’;<br>this.prototype.hello = function () {<br>    alert(‘Hello, ‘ + this.name + ‘!’);<br>}<br>}<br>  这就是call方法<br>它会运行一个函数，然后告诉这个函数你现在得用我给你的对象来运行你的那套方法，返回出什么东西是什么东西</p>
<p>2.原型继承</p>
<p>而原型继承呢<br>一般我们会先定义一个方法  比如刚才的Student<br>Student方法里有属性，有定义在原型里的方法<br>然后我们想继承Student，我们定义出一个新的函数 littleStudent<br>在这个新的函数内部我们  Student.call(this,arg)   在这里this指的是littleStudent，按上面定义的Student函数（内部拿this写属性和方法），我们会获得一个littleStudent它内部有Student的那些属性和方法<br>等于Student在我们littleStudent内部执行了一遍，并且是为我们造属性和方法的，我们littleStudent现在也有这些方法了<br>但这样是继承吗？Student日后有改变，我们的littleStudent会有改变吗，不会<br>因为我们只是拿call让Student给我们也造了一套属性的方法，我们littleStudent的原型仍然指向littleStudent.protptype<br>当前的原型链是职业的  new littleStudent() —-&gt; littleStudent.prototype —-&gt; Object.prototype —-&gt; null   跟Student没有关系<br>需要变成这样  new littleStudent() —-&gt; littleStudent.prototype —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null<br>那么怎么继承呢</p>
<p>先创建一个空函数F（）{     }<br>把这个空函数的原型指向Student的原型：F.prototype = Student.prototype;<br>然后把littleStudent的原型指向F的实例：littleStudent.prototype=new F();；   则littleStudent的原型里包含了student原型里的所有内容<br>然后把littleStudent原型的构造函数修复为littleStudent：littleStudent.prototype.constructor = littleStudent;   因为之前littleStudent.prototype=new F()   则new F().constructor指向的是构造函数F<br>然后我们就可以继续在littleStudent对象的原型上添加方法和属性了<br>littleStudent.prototype.getGrade = function () {<br>    return this.grade;<br>};<br>而这并不会影响Student的原型，因为我们在这儿添加方法相当于是在new F()上添加方法<br>至此我们又给littleStudent继承了Student的原型，又可以随意给它扩展，这就完成了一次继承</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/04/基础内容回顾/" itemprop="url">
                  基础内容回顾
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-04T22:37:02+08:00" content="2016-01-04">
              2016-01-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.高阶函数指把函数作为参数的函数，map和reduce就是两个高阶函数</p>
<p>map接受一个方法作为参数，可以对一个数列中的每一个元素拿此方法做处理，像这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">1</span>&#125;</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(pow)</div><div class="line"><span class="comment">//[2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure></p>
<p>reduce接受一个方法作为参数，这个方法必须有两个参数，可以对一个数列中的元素做累计处理，第一个参数为数组处理的累积返回值，第二个参数为新加入处理的数组元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].reduce(pow)</div><div class="line"><span class="number">15</span></div></pre></td></tr></table></figure></p>
<p>但是需要注意的是，map和reduce只需要处理数组的方法，即只需要传reduce(pow)，不需要reduce(pow())；另外，map和reduce是两个方法，两个api，直接跟在数组后面，如：[1,2,3,4,5].reduce(pow)</p>
<p>2.闭包</p>
<p>闭包指的就是一个函数里面返回了一个函数，或者这个函数返回的值里有未执行的函数，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> i * i;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>count()，执行后返回了arr数组，arr数组中每一个元素都是一个未执行的函数，返回出来是这样的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">count()</div><div class="line">[funciton() &#123;<span class="keyword">return</span> i * i;&#125;,funciton() &#123;<span class="keyword">return</span> i * i;&#125;,funciton() &#123;<span class="keyword">return</span> i * i;&#125;]</div></pre></td></tr></table></figure></p>
<p>这就是闭包了，返回了未执行的函数或者返回的值里包含未执行的函数，这里要说的是闭包的第一个特性，闭包可以保存外部函数带来的数据：</p>
<p>  比如一个函数内含闭包，在闭包外声明var a=1;然后闭包中也用了a，那么外部这个函数执行完后会返回这个闭包，闭包中这个a=1的值仍然保存，单独放在那里也保存着a=1，因为闭包是一个“携带状态的函数，并且它的状态可以完全对外隐藏起来”</p>
<p>比如下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">inc</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            x += <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c1 = create_counter();</div><div class="line">c1.inc(); <span class="comment">// 1</span></div><div class="line">c1.inc(); <span class="comment">// 2</span></div><div class="line">c1.inc(); <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</div><div class="line">c2.inc(); <span class="comment">// 11</span></div><div class="line">c2.inc(); <span class="comment">// 12</span></div><div class="line">c2.inc(); <span class="comment">// 13</span></div></pre></td></tr></table></figure></p>
<p>如以上代码，x的值在闭包中始终存在。</p>
<p>我之前疑惑的一点是在调用c1.inc()时，c1不是等于create_counter()吗?它每c1.inc（）一次，先执行c1时难道不会把x再次初始化吗，那闭包中保存的值不是被初始化了</p>
<p>后来想了想，原来c1=create_counter()意思是c1是create_counter这个函数执行后的返回值，它的返回值是什么，是闭包啊，没有那个初始化语句了，所以上面说“先执行c1”是可笑的，因为它只是一个值而已，它只是一个执行过的函数返回的值而已</p>
<p>闭包的第二个特性就是，闭包保存的值（外部的值沿用到内部因未执行保存起来的），保存的是这个值的最后一个状态</p>
<p>什么意思呢<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> i * i;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个最终返回的是[16,16,16]，因为i循环完了的时候，返回的闭包还是[funciton() {return i <em> i;},funciton() {return i </em> i;},funciton() {return i * i;}]</p>
<p>并没有执行，但是i已经等于4了，所以等它们重见天日的时候，它们内部保存的状态（值）是i=4</p>
<p>待续</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Stan Xi" />
          <p class="site-author-name" itemprop="name">Stan Xi</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stan Xi</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
